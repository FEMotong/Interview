浅拷贝:  

    遍历复制,得到新对象   

    1. JSON.parse()

    var syb = Symbol('obj');
    var person = {
      name :'tino',
      say: function(){
          console.log('hi');
      },
      ok: syb,
      un: undefined
    }
    var copy = JSON.parse(JSON.stringify(person))
    copy.name = "abil"
    22:41:38.830 "abil"
    22:41:54.409 person.name;
    22:41:54.411 "tino"
    22:42:07.592 copy.name
    22:42:07.597 "abil"

    优点: Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构
    缺点: undefined,function,Symbol,RegExp无法拷贝


   
   2. ES6=>Object.assign()  

    Object.assign(target, ...sources)
    /*
    *@params Object  若此目标对象与来源对象有相同键,则被覆盖
    *@params Object  来源对象
    *@return Object
    */
  
    let obj = { a: 1, b: 2, c: 3 };
    let cloneObj = Object.assign({}, obj);
    cloneObj2.b = 4;
    console.log(obj);
    // { a: 1, b: 2, c: 3 }     //没有修改
    console.log(cloneObj2);
    // { a: 10, b: 4, c: 30 }
    
    //只遍历sources可枚举属性(for..in..)
    
深拷贝  

    描述:  
      复制一个所有属性和方法的新对象,深拷贝技术.  
      对象的属性是引用类型时，进行递归遍历复制，直到遍历完所有属性  
 1. 常用深拷贝方法
```javascript
function deepClone(obj) {
//判断类型是否对象,优化
if(typeof obj !== "Object") {
    return obj
}
//判断是数组或者是对象
if(obj instanceof Array) {
    newObj = []
}else {
    newObj = {}
}
for(let key in obj) {
    //若不是对象,直接添加到数组
    if(typeof obj[key] !== "Object") {
        newObj[key] = obj[key]
    }else {
        newObj[key] = deepClone(obj[key])   //若是对象,进行递归
    }
}
return newObj
}
```  



   
    
